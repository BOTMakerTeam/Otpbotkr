# FILE: otpbot_v4.7_country_fix.py (COUNTRY DETECTION & DIAGNOSTIC FIX)

import requests
from bs4 import BeautifulSoup
import time
import re
import sys
import signal
import sqlite3
import os
import threading
import hashlib
import queue
import random
from datetime import datetime, timedelta

# --- Configuration ---
BOT_NAME = "BlackX Bot"
USERNAME = "BlackX"
PASSWORD = "BlackX@#"
DB_FILE = "sms_database_np.db" 

# --- Telegram Configuration ---
TELEGRAM_BOT_TOKEN = "8471160586:AAEq28YvhgQ26pR9Wb8GNfbb3ZXdxwKxOYA"
DEFAULT_GROUP_CHAT_ID = "-1002820927082" 
DM_CHAT_ID = "7701278483" 

# --- New Configuration ---
DEVELOPER_NAME = "Heart"
DEVELOPER_TG_ID = "7701278483" 

# --- API Endpoints ---
BASE_URL = "http://51.89.99.105/NumberPanel"
DOMAIN_URL = "http://51.89.99.105"
LOGIN_PAGE_URL = f"{BASE_URL}/"
SMS_HTML_PAGE_URL = f"{BASE_URL}/client/SMSCDRStats" 

POTENTIAL_API_URLS = [
    f"{BASE_URL}/client/res/data_smscdr.php",
    f"{DOMAIN_URL}/res/data_smscdr.php",
    f"{BASE_URL}/res/data_smscdr.php"
]
working_api_url = None 

# --- Global variables ---
db_connection = None
stop_event = threading.Event()
reported_sms_hashes_cache = set()

# --- Data for Formatting ---

# <<< à¦¸à¦®à¦¾à¦§à¦¾à¦¨: à¦•à¦¾à¦¨à§à¦Ÿà§à¦°à¦¿ à¦•à§‹à¦¡à§‡à¦° à¦¸à¦®à§à¦ªà§‚à¦°à§à¦£ à¦¤à¦¾à¦²à¦¿à¦•à¦¾ à¦†à¦¬à¦¾à¦° à¦¯à§‹à¦— à¦•à¦°à¦¾ à¦¹à¦²à§‹ >>>
COUNTRY_CODES = {
    '1': ('USA/Canada', 'ðŸ‡ºðŸ‡¸'), '7': ('Russia', 'ðŸ‡·ðŸ‡º'), '20': ('Egypt', 'ðŸ‡ªðŸ‡¬'), '27': ('South Africa', 'ðŸ‡¿ðŸ‡¦'),
    '30': ('Greece', 'ðŸ‡¬ðŸ‡·'), '31': ('Netherlands', 'ðŸ‡³ðŸ‡±'), '32': ('Belgium', 'ðŸ‡§ðŸ‡ª'), '33': ('France', 'ðŸ‡«ðŸ‡·'),
    '34': ('Spain', 'ðŸ‡ªðŸ‡¸'), '36': ('Hungary', 'ðŸ‡­ðŸ‡º'), '39': ('Italy', 'ðŸ‡®ðŸ‡¹'), '40': ('Romania', 'ðŸ‡·ðŸ‡´'),
    '41': ('Switzerland', 'ðŸ‡¨ðŸ‡­'), '43': ('Austria', 'ðŸ‡¦ðŸ‡¹'), '44': ('United Kingdom', 'ðŸ‡¬ðŸ‡§'), '45': ('Denmark', 'ðŸ‡©ðŸ‡°'),
    '46': ('Sweden', 'ðŸ‡¸ðŸ‡ª'), '47': ('Norway', 'ðŸ‡³ðŸ‡´'), '48': ('Poland', 'ðŸ‡µðŸ‡±'), '49': ('Germany', 'ðŸ‡©ðŸ‡ª'),
    '51': ('Peru', 'ðŸ‡µðŸ‡ª'), '52': ('Mexico', 'ðŸ‡²ðŸ‡½'), '53': ('Cuba', 'ðŸ‡¨ðŸ‡º'), '54': ('Argentina', 'ðŸ‡¦ðŸ‡·'),
    '55': ('Brazil', 'ðŸ‡§ðŸ‡·'), '56': ('Chile', 'ðŸ‡¨ðŸ‡±'), '57': ('Colombia', 'ðŸ‡¨ðŸ‡´'), '58': ('Venezuela', 'ðŸ‡»ðŸ‡ª'),
    '60': ('Malaysia', 'ðŸ‡²ðŸ‡¾'), '61': ('Australia', 'ðŸ‡¦ðŸ‡º'), '62': ('Indonesia', 'ðŸ‡®ðŸ‡©'), '63': ('Philippines', 'ðŸ‡µðŸ‡­'),
    '64': ('New Zealand', 'ðŸ‡³ðŸ‡¿'), '65': ('Singapore', 'ðŸ‡¸ðŸ‡¬'), '66': ('Thailand', 'ðŸ‡¹ðŸ‡­'), '81': ('Japan', 'ðŸ‡¯ðŸ‡µ'),
    '82': ('South Korea', 'ðŸ‡°ðŸ‡·'), '84': ('Vietnam', 'ðŸ‡»ðŸ‡³'), '86': ('China', 'ðŸ‡¨ðŸ‡³'), '90': ('Turkey', 'ðŸ‡¹ðŸ‡·'),
    '91': ('India', 'ðŸ‡®ðŸ‡³'), '92': ('Pakistan', 'ðŸ‡µðŸ‡°'), '93': ('Afghanistan', 'ðŸ‡¦ðŸ‡«'), '94': ('Sri Lanka', 'ðŸ‡±ðŸ‡°'),
    '95': ('Myanmar', 'ðŸ‡²ðŸ‡²'), '98': ('Iran', 'ðŸ‡®ðŸ‡·'), '212': ('Morocco', 'ðŸ‡²ðŸ‡¦'), '213': ('Algeria', 'ðŸ‡©ðŸ‡¿'),
    '216': ('Tunisia', 'ðŸ‡¹ðŸ‡³'), '218': ('Libya', 'ðŸ‡±ðŸ‡¾'), '221': ('Senegal', 'ðŸ‡¸ðŸ‡³'), '223': ('Mali', 'ðŸ‡²ðŸ‡±'),
    '224': ('Guinea', 'ðŸ‡¬ðŸ‡³'), '225': ("CÃ´te d'Ivoire", 'ðŸ‡¨ðŸ‡®'), '226': ('Burkina Faso', 'ðŸ‡§ðŸ‡«'), '227': ('Niger', 'ðŸ‡³ðŸ‡ª'),
    '228': ('Togo', 'ðŸ‡¹ðŸ‡¬'), '229': ('Benin', 'ðŸ‡§ðŸ‡¯'), '230': ('Mauritius', 'ðŸ‡²ðŸ‡º'), '233': ('Ghana', 'ðŸ‡¬ðŸ‡­'),
    '234': ('Nigeria', 'ðŸ‡³ðŸ‡¬'), '237': ('Cameroon', 'ðŸ‡¨ðŸ‡²'), '245': ('Guinea-Bissau', 'ðŸ‡¬ðŸ‡¼'), '251': ('Ethiopia', 'ðŸ‡ªðŸ‡¹'),
    '254': ('Kenya', 'ðŸ‡°ðŸ‡ª'), '255': ('Tanzania', 'ðŸ‡¹ðŸ‡¿'), '256': ('Uganda', 'ðŸ‡ºðŸ‡¬'), '258': ('Mozambique', 'ðŸ‡²ðŸ‡¿'),
    '260': ('Zambia', 'ðŸ‡¿ðŸ‡²'), '263': ('Zimbabwe', 'ðŸ‡¿ðŸ‡¼'), '351': ('Portugal', 'ðŸ‡µðŸ‡¹'), '353': ('Ireland', 'ðŸ‡®ðŸ‡ª'),
    '354': ('Iceland', 'ðŸ‡®ðŸ‡¸'), '358': ('Finland', 'ðŸ‡«ðŸ‡®'), '375': ('Belarus', 'ðŸ‡§ðŸ‡¾'), '380': ('Ukraine', 'ðŸ‡ºðŸ‡¦'),
    '420': ('Czech Republic', 'ðŸ‡¨ðŸ‡¿'), '855': ('Cambodia', 'ðŸ‡°ðŸ‡­'), '856': ('Laos', 'ðŸ‡±ðŸ‡¦'),
    '880': ('Bangladesh', 'ðŸ‡§ðŸ‡©'), '886': ('Taiwan', 'ðŸ‡¹ðŸ‡¼'), '961': ('Lebanon', 'ðŸ‡±ðŸ‡§'), '962': ('Jordan', 'ðŸ‡¯ðŸ‡´'),
    '963': ('Syria', 'ðŸ‡¸ðŸ‡¾'), '964': ('Iraq', 'ðŸ‡®ðŸ‡¶'), '965': ('Kuwait', 'ðŸ‡°ðŸ‡¼'), '966': ('Saudi Arabia', 'ðŸ‡¸ðŸ‡¦'),
    '967': ('Yemen', 'ðŸ‡¾ðŸ‡ª'), '968': ('Oman', 'ðŸ‡´ðŸ‡²'), '971': ('United Arab Emirates', 'ðŸ‡¦ðŸ‡ª'), '973': ('Bahrain', 'ðŸ‡§ðŸ‡­'),
    '974': ('Qatar', 'ðŸ‡¶ðŸ‡¦'), '976': ('Mongolia', 'ðŸ‡²ðŸ‡³'), '977': ('Nepal', 'ðŸ‡³ðŸ‡µ'), '998': ('Uzbekistan', 'ðŸ‡ºðŸ‡¿'),
}

QURANIC_VERSES = [
    ("à¦à¦¬à¦‚ à¦¸à¦¾à¦¹à¦¾à¦¯à§à¦¯ à¦ªà§à¦°à¦¾à¦°à§à¦¥à¦¨à¦¾ à¦•à¦° à¦§à§ˆà¦°à§à¦¯à§à¦¯ à¦“ à¦¨à¦¾à¦®à¦¾à¦¯à§‡à¦° à¦®à¦¾à¦§à§à¦¯à¦®à§‡à¥¤ à¦¨à¦¿à¦¶à§à¦šà§Ÿ à¦¤à¦¾ à¦•à¦ à¦¿à¦¨, à¦•à¦¿à¦¨à§à¦¤à§ à¦¬à¦¿à¦¨à§€à¦¤à¦¦à§‡à¦° à¦œà¦¨à§à¦¯à§‡ à¦¨à§Ÿà¥¤", "à¦¸à§‚à¦°à¦¾ à¦†à¦²-à¦¬à¦¾à¦•à¦¾à¦°à¦¾, à¦†à§Ÿà¦¾à¦¤ à§ªà§«"),
    ("à¦†à¦²à§à¦²à¦¾à¦¹ à¦•à§‹à¦¨ à¦¬à§à¦¯à¦•à§à¦¤à¦¿à¦° à¦‰à¦ªà¦° à¦¤à¦¾à¦° à¦¸à¦¾à¦§à§à¦¯à¦¾à¦¤à§€à¦¤ à¦•à§‡à¦¾à¦¨ à¦•à¦¾à¦œà§‡à¦° à¦¦à¦¾à§Ÿà¦¿à¦¤à§à¦¬ à¦šà¦¾à¦ªà¦¿à§Ÿà§‡ à¦¦à§‡à¦¨ à¦¨à¦¾à¥¤", "à¦¸à§‚à¦°à¦¾ à¦†à¦²-à¦¬à¦¾à¦•à¦¾à¦°à¦¾, à¦†à§Ÿà¦¾à¦¤ à§¨à§®à§¬"),
    ("à¦à¦¬à¦‚ à¦¤à§‡à¦¾à¦®à¦°à¦¾ à¦¨à¦¿à¦°à¦¾à¦¶ à¦¹à§Ÿà§‡à¦¾ à¦¨à¦¾ à¦à¦¬à¦‚ à¦¦à§à¦ƒà¦– à¦•à¦°à§‡à¦¾ à¦¨à¦¾à¥¤ à¦¯à¦¦à¦¿ à¦¤à§‡à¦¾à¦®à¦°à¦¾ à¦®à§à¦®à¦¿à¦¨ à¦¹à¦“, à¦¤à¦¬à§‡ à¦¤à§‡à¦¾à¦®à¦°à¦¾à¦‡ à¦œà§Ÿà§€ à¦¹à¦¬à§‡à¥¤", "à¦¸à§‚à¦°à¦¾ à¦†à¦²-à¦‡à¦®à¦°à¦¾à¦¨, à¦†à§Ÿà¦¾à¦¤ Û±Û³Û¹"),
    ("à¦¯à¦¾à¦°à¦¾ à¦†à¦²à§à¦²à¦¾à¦¹ à¦“ à¦¶à§‡à¦· à¦¦à¦¿à¦¬à¦¸à§‡à¦° à¦†à¦¶à¦¾ à¦°à¦¾à¦–à§‡ à¦à¦¬à¦‚ à¦†à¦²à§à¦²à¦¾à¦¹à¦•à§‡ à¦…à¦§à¦¿à¦• à¦¸à§à¦®à¦°à¦£ à¦•à¦°à§‡, à¦¤à¦¾à¦¦à§‡à¦° à¦œà¦¨à§à¦¯à§‡ à¦°à¦¸à§‚à¦²à§à¦²à§à¦²à¦¾à¦¹à¦° à¦®à¦§à§à¦¯à§‡ à¦‰à¦¤à§à¦¤à¦® à¦¨à¦®à§à¦¨à¦¾ à¦°à§Ÿà§‡à¦›à§‡à¥¤", "à¦¸à§‚à¦°à¦¾ à¦†à¦²-à¦†à¦¹à¦¯à¦¾à¦¬, à¦†à§Ÿà¦¾à¦¤ à§¨à§§"),
    ("à¦¬à¦²à§à¦¨, à¦¹à§‡ à¦†à¦®à¦¾à¦° à¦¬à¦¾à¦¨à§à¦¦à¦¾à¦—à¦£! à¦¯à¦¾à¦°à¦¾ à¦¨à¦¿à¦œà§‡à¦¦à§‡à¦° à¦‰à¦ªà¦° à¦¯à§à¦²à§à¦® à¦•à¦°à§‡à¦› à¦¤à§‡à¦¾à¦®à¦°à¦¾ à¦†à¦²à§à¦²à¦¾à¦¹à¦° à¦°à¦¹à¦®à¦¤ à¦¥à§‡à¦•à§‡ à¦¨à¦¿à¦°à¦¾à¦¶ à¦¹à§Ÿà§‡à¦¾ à¦¨à¦¾à¥¤", "à¦¸à§‚à¦°à¦¾ à¦†à¦¯-à¦¯à§à¦®à¦¾à¦°, à¦†à§Ÿà¦¾à¦¤ à§«à§©"),
    ("à¦¨à¦¿à¦¶à§à¦šà§Ÿ à¦•à¦·à§à¦Ÿà§‡à¦° à¦¸à¦¾à¦¥à§‡ à¦¸à§à¦¬à¦¸à§à¦¤à¦¿ à¦°à§Ÿà§‡à¦›à§‡à¥¤", "à¦¸à§‚à¦°à¦¾ à¦†à¦²-à¦‡à¦¨à¦¶à¦¿à¦°à¦¾à¦¹, à¦†à§Ÿà¦¾à¦¤ à§¬"),
    ("à¦ªà§œà§à¦¨ à¦†à¦ªà¦¨à¦¾à¦° à¦ªà¦¾à¦²à¦¨à¦•à¦°à§à¦¤à¦¾à¦° à¦¨à¦¾à¦®à§‡ à¦¯à¦¿à¦¨à¦¿ à¦¸à§ƒà¦·à§à¦Ÿà¦¿ à¦•à¦°à§‡à¦›à§‡à¦¨à¥¤", "à¦¸à§‚à¦°à¦¾ à¦†à¦²-à¦†à¦²à¦¾à¦•, à¦†à§Ÿà¦¾à¦¤ à§§"),
]

def get_country_info(phone_number):
    for i in range(4, 0, -1):
        prefix = phone_number[:i]
        if prefix in COUNTRY_CODES: return COUNTRY_CODES[prefix]
    return ('Unknown', 'â“')

def detect_service(sender_name, message_text):
    full_text = (sender_name + " " + message_text).lower()
    services = ['whatsapp', 'facebook', 'google', 'telegram', 'instagram', 'discord', 'twitter', 'snapchat', 'imo', 'tiktok']
    for service in services:
        if service in full_text: return service.capitalize()
    return sender_name if sender_name else "Unknown"

def format_telegram_message(recipient_number, sender_name, message, otp, sms_time):
    country_name, country_flag = get_country_info(recipient_number)
    service_name = detect_service(sender_name, message)
    verse, surah_info = random.choice(QURANIC_VERSES)
    developer_link = f"[{DEVELOPER_NAME}](tg://user?id={DEVELOPER_TG_ID})"
    
    return f"""âœ… {country_flag} *{country_name} {service_name} OTP Code Received!*
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ðŸ“± *Number:* `{recipient_number}`
ðŸŒ *Country:* {country_flag} {country_name}
âš™ï¸ *Service:* {service_name}
ðŸ”’ *OTP Code:* `{otp}`
â³ *Time:* `{sms_time}`
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
*Message:*
```{message}```
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
*ðŸ“– à¦ªà¦¬à¦¿à¦¤à§à¦° à¦•à§à¦°à¦†à¦¨:*
> _{verse}_
> â€” _{surah_info}_
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
*Bot Developer:* {developer_link}
---
*Powered By Stream Vault Method*"""

class TelegramSender:
    def __init__(self, token, stop_signal):
        self.token, self.queue, self.stop_event = token, queue.Queue(), stop_signal
        self.thread = threading.Thread(target=self._worker, daemon=True)
    def start(self): self.thread.start(); print("[*] Telegram Sender thread started.")
    def _worker(self):
        while not self.stop_event.is_set():
            try:
                chat_id, text, sms_hash = self.queue.get(timeout=1)
                if self._send_message(chat_id, text): add_sms_to_reported_db(sms_hash)
                self.queue.task_done()
            except queue.Empty: continue
    def _send_message(self, chat_id, text):
        api_url = f"https://api.telegram.org/bot{self.token}/sendMessage"
        payload = {'chat_id': chat_id, 'text': text, 'parse_mode': 'Markdown', 'disable_web_page_preview': True}
        try:
            r = requests.post(api_url, json=payload, timeout=20)
            if r.status_code != 200: print(f"[!] Telegram API Error: {r.status_code} - {r.text}")
            return r.status_code == 200
        except Exception as e:
            print(f"[!] Failed to send message to Telegram: {e}"); return False
    def queue_message(self, chat_id, text, sms_hash): self.queue.put((chat_id, text, sms_hash))

telegram_sender = TelegramSender(TELEGRAM_BOT_TOKEN, stop_event)

def setup_database():
    global db_connection, reported_sms_hashes_cache
    try:
        db_connection = sqlite3.connect(DB_FILE, check_same_thread=False)
        cursor = db_connection.cursor()
        cursor.execute('CREATE TABLE IF NOT EXISTS reported_sms (hash TEXT PRIMARY KEY)')
        reported_sms_hashes_cache = {row[0] for row in cursor.execute("SELECT hash FROM reported_sms")}
        db_connection.commit(); print(f"[*] Database connected. Loaded {len(reported_sms_hashes_cache)} hashes.")
        return True
    except sqlite3.Error as e: print(f"[!!!] DATABASE ERROR: {e}"); return False

def add_sms_to_reported_db(sms_hash):
    try:
        with db_connection: db_connection.execute("INSERT INTO reported_sms (hash) VALUES (?)", (sms_hash,))
    except sqlite3.Error: pass

def send_operational_message(chat_id, text):
    try: requests.post(f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendMessage", json={'chat_id': chat_id, 'text': f"{text}\n\nðŸ¤– _{BOT_NAME}_", 'parse_mode': 'Markdown'}, timeout=15)
    except Exception: pass

def graceful_shutdown(signum, frame):
    print("\n[!!!] Shutdown signal detected. Stopping.")
    stop_event.set()
    time.sleep(1)
    if db_connection: db_connection.close()
    sys.exit(0)

def solve_math_captcha(captcha_text):
    match = re.search(r'(\d+)\s*([+*])\s*(\d+)', captcha_text)
    if not match: return None
    n1, op, n2 = int(match.group(1)), match.group(2), int(match.group(3))
    result = n1 + n2 if op == '+' else n1 * n2
    print(f"[*] Solved Captcha: {n1} {op} {n2} = {result}")
    return result

def start_watching_sms(session, destination_chat_id):
    global working_api_url
    polling_interval = 1
    
    while not stop_event.is_set():
        try:
            print(f"[*] Fetching SMS data... ({time.strftime('%H:%M:%S')})")
            print(f"    - Current session cookies: {session.cookies.get_dict()}")

            if not working_api_url:
                print("[!] Working API URL not set. Trying to find it again...")
                for url_to_test in POTENTIAL_API_URLS:
                    try:
                        test_response = session.get(url_to_test, timeout=20, params={'sEcho': '1'})
                        if test_response.status_code != 404:
                            print(f"[SUCCESS] Found working API URL: {url_to_test}")
                            working_api_url = url_to_test; break
                    except requests.exceptions.RequestException: pass
                if not working_api_url:
                    print("[!!!] CRITICAL: Could not find a working API URL. Bot cannot proceed.")
                    graceful_shutdown(None, None)

            date_to, date_from = datetime.now(), datetime.now() - timedelta(days=1)
            params = {'fdate1': date_from.strftime('%Y-%m-%d %H:%M:%S'), 'fdate2': date_to.strftime('%Y-%m-%d %H:%M:%S')}
            api_headers = {"Accept": "application/json, text/javascript, */*; q=0.01", "X-Requested-With": "XMLHttpRequest", "Referer": SMS_HTML_PAGE_URL}
            
            response = session.get(working_api_url, params=params, headers=api_headers, timeout=30)
            
            print(f"    - API Status Code: {response.status_code}")
            print(f"    - API Response (first 150 chars): {response.text[:150]}")

            response.raise_for_status()
            json_data = response.json()
            
            if 'aaData' in json_data and isinstance(json_data['aaData'], list):
                sms_list = json_data['aaData']
                print(f"    - Found {len(sms_list)} SMS entries in the API response.")
                
                for sms_data in reversed(sms_list):
                    if len(sms_data) > 4:
                        dt, rc, sn, msg = str(sms_data[0]), str(sms_data[2]), str(sms_data[3]), str(sms_data[4])
                        
                        if not msg or not rc or rc.strip() == '0' or len(rc.strip()) < 5:
                            print(f"    - Ignoring invalid/empty SMS data: Number='{rc}', Message='{msg}'")
                            continue

                        h = hashlib.md5(f"{dt}-{rc}-{msg}".encode()).hexdigest()
                        
                        print(f"    - Processing SMS for {rc}. Hash: {h}")
                        if h not in reported_sms_hashes_cache:
                            reported_sms_hashes_cache.add(h)
                            print(f"    - [+] New SMS Queued! For: {rc}")
                            otp_match = re.search(r'\b(\d{3}[-\s]\d{3})\b|\b(\d{4,8})\b', msg)
                            otp = otp_match.group(0) if otp_match else "N/A"
                            notification_message = format_telegram_message(rc, sn, msg, otp, dt)
                            telegram_sender.queue_message(destination_chat_id, notification_message, h)
                        else:
                            print(f"    - [-] Duplicate SMS ignored (hash already in cache).")
            else:
                print("[!] API response format is not as expected. 'aaData' key not found or is not a list.")
            
            print("-" * 40)
            time.sleep(polling_interval)
            
        except requests.exceptions.RequestException as e: print(f"[!] Network error: {e}. Retrying..."); time.sleep(30)
        except Exception as e: print(f"[!!!] CRITICAL ERROR in SMS watch loop: {e}"); time.sleep(30)

def main():
    signal.signal(signal.SIGINT, graceful_shutdown)
    print("="*60 + "\n--- NumberPanel OTP Bot (v4.7 Country Fix) ---\n" + "="*60)
    if not setup_database(): return
    
    try:
        with requests.Session() as session:
            session.headers.update({'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36'})
            print("\n[*] Step 1: Logging in...")
            r = session.get(LOGIN_PAGE_URL, timeout=20); soup = BeautifulSoup(r.text, 'html.parser')
            form = soup.find('form');
            if not form: raise Exception("Could not find <form> tag.")
            post_url = form.get('action')
            if not post_url.startswith('http'): post_url = f"{BASE_URL}/{post_url.lstrip('/')}"
            
            payload = {}
            for tag in form.find_all('input'):
                n, v, p = tag.get('name'), tag.get('value', ''), tag.get('placeholder', '').lower()
                if not n: continue
                if 'user' in p: payload[n] = USERNAME
                elif 'pass' in p: payload[n] = PASSWORD
                elif 'ans' in p:
                    el = soup.find(string=re.compile(r'What is \d+ \s*[+*]\s* \d+'))
                    if not el: raise Exception("Could not find captcha text.")
                    payload[n] = solve_math_captcha(el)
                else: payload[n] = v
            
            r = session.post(post_url, data=payload, headers={'Referer': LOGIN_PAGE_URL})
            
            if "dashboard" in r.url.lower() or "Logout" in r.text:
                print("[SUCCESS] Authentication complete!")
                print(f"    - Final URL: {r.url}")
                print(f"    - Final Session Cookies: {session.cookies.get_dict()}")
                telegram_sender.start()
                send_operational_message(DM_CHAT_ID, "âœ… *Bot Started & Logged In!*\n\nWatching for SMS on NumberPanel.")
                start_watching_sms(session, DEFAULT_GROUP_CHAT_ID)
            else:
                print("\n[!!!] AUTHENTICATION FAILED.")
                e_div = BeautifulSoup(r.text, 'html.parser').find('div', class_='alert-danger')
                print(f"    - Reason: {e_div.get_text(strip=True)}" if e_div else f"    - Status: {r.status_code}, URL: {r.url}. Check credentials.")
                print(f"    - Full response on failure: {r.text[:500]}")
    except Exception as e:
        print(f"\n[!!!] Critical startup error: {e}")

if __name__ == "__main__":
    main()